<!DOCTYPE html>
<html lang="en-us">
    <head><title>John Jarvis</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="" />
<style type="text/css">@font-face {
  font-family: fabfont;
  src: url('/font/DejaVuSansMono.woff2');
  font-display: block;
}

@font-face {
  font-family: fabfont;
  src: url('/font/DejaVuSansMono-Bold.woff2');
  font-weight: bold;
  font-display: block;
}

main h1 {
  font-weight: bold;
  text-transform: uppercase;
  font-size: 1.2rem;
  border-bottom: 1px solid black;
}

html {
  font-size: 14px;
  color: black;
}

body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  font-family: fabfont,  monospace;
  background: #F5F5F0;
}

body > * {
  width: 700px;
  margin: 0 auto;
}

table {
  border-collapse: collapse;
}

td, th {
  text-align: left;
}

@media only screen and (width <= 800px) {
  body > * {
    width: auto;
    margin: 0 1.2em;
  }
}

a {
  font-weight: bold;
  color: black;
}

p {
  text-align: justify;
}

img {
  width: 100%;
}

/* index.html */

main {
  line-height: 1.5;
}

main ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

/* header */

header {
  font-weight: bold;
  text-transform: uppercase;
  margin-top: 4ch;
  margin-top: 1em;
  display: flex;
}


header a {
  text-decoration: none;
}

header h2 {
  font-size: 14px;
  width: 50%;
  margin: 0;
  padding: 0;
}

header aside {
  width: 50%;
  text-align: right;
}

header aside ul {
  margin: 0;
  padding: 0;
  list-style: none;
  justify-content: space-between;
}

header aside ul > li {
  display: inline-block;
}

/* articles */

main article aside {
  display: flex;
  margin: 0;
  color: gray;
  font-size: .9em;
}

main article aside ul li a {
  color: gray;
  text-decoration: none;
}

main article aside time {
  display: flex;
  width: 50%;
}

main article aside ul {
  margin: 0;
  padding: 0;
  width: 50%;
  text-align: right;
  list-style: none;
  justify-content: space-between;
}

main article > pre {
  background-color: #e1e1e1;
  overflow-x: auto;
  padding: .8em;
  font-size: .9em;
  box-shadow: 0 -1px 0 #bbb inset;
}

/* code hylights */
main article .highlight pre {
  overflow-x: auto;
  font-size: .8em;
  padding: .8em;
}

main article p code {
    font-weight: bold;
    background-color: #e1e1e1;
    border-radius: 0.5ch;
    padding-left: 0.3ch;
    padding-right: 0.3ch;
}

/* blockquote */

blockquote {
  font-style:italic;
  color: #555;
  padding:1.2em 30px 1.2em 45px;
  border-left:8px solid #696969;
  position: relative;
  background: #EDEDED;
  line-height: 1.6;
}

blockquote p {
  text-align: left;

}

blockquote::before {
  font-family: Arial, Helvetica, sans-serif;
  content: "\201C";
  color: #696969;
  font-size:4em;
  position: absolute;
  left: 10px;
  top: -10px;
}

blockquote::after {
  content: '';
}

@media only screen and (width <= 800px) {
  blockquote {
    margin: 1em 0;
    padding: .5em;
  }
}
</style>
</head>
    <body>
        <header><h2><a href="/"><b>John Jarvis</b></a></h2>
<aside>
  <ul>
    <li><a href="/about/">ABOUT</a></li>
    <li><a href="/contact/">CONTACT</a></li>
    <li><a href="https://jarv.org/index.xml">RSS</a></li>
  </ul>
</aside>
</header>
        <main>
<article>
    <h1>Cat without cat on the commandline</h1>
    <aside>
  
  <time datetime="2020-07-30T00:00:00Z">Jul 30, 2020</time>
  
  <ul>
    <li>
    </li>
    
    <li>
      <em>
        
        
        <a href="/tags/cmdchallenge">#cmdchallenge</a>
        
      </em>
    </li>
    
  </ul>
</aside>

    <p>Say you want to display the contents of a file on the command line. The first tool we most of us reach for is <code>cat</code>, which does a fine job at just this.
But what happens when you are on a Linux machine and when you try to cat a file this happens:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat file.txt
</span></span><span style="display:flex;"><span>-bash: cat: <span style="color:#0086b3">command</span> not found
</span></span></code></pre></div><p>or even:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat file.txt
</span></span><span style="display:flex;"><span>bash: fork: retry: No child processes
</span></span></code></pre></div><p>This post explores this idea and was a feature of this <a href="https://oops.cmdchallenge.com/#/oops_print_file_contents">challenge</a> where you needed to display a file&rsquo;s contents without using any utility outside of the shell.</p>
<hr>
<h2 id="using-shell-built-ins-redirection-and-subshell">Using shell built-ins, redirection and subshell</h2>
<p>Using the shell builtin <code>read</code> you can display the contents of a file, without a forking a new process:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> <span style="color:#0086b3">read</span> line; <span style="color:#000;font-weight:bold">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#0086b3">echo</span> <span style="color:#008080">$line</span>;
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">done</span> &lt;file.txt
</span></span></code></pre></div><p>From the help page for <code>read</code>:</p>
<blockquote>
<p>One line is read from the standard input, or from file descriptor FD if the -u option is supplied, and the first word is assigned to the first NAME,</p>
</blockquote>
<p>In this example, the contents of file.txt are redirected to the STDIN of <code>read</code>, which processes the input line by line, until it reaches the end of the file. <code>read</code> also can take a file descriptor as its input instead of STDIN, so this will also work:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#0086b3">exec</span> 3&lt;file.txt <span style="color:#998;font-style:italic"># Assign file descriptor 3 for reading</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">while</span> <span style="color:#0086b3">read</span> -u <span style="color:#099">3</span> line; <span style="color:#000;font-weight:bold">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#0086b3">echo</span> <span style="color:#008080">$line</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">done</span>
</span></span></code></pre></div><p>This ends up being a lot more typing than just <code>cat file.txt</code>. With the <code>bash</code> or <code>zsh</code> there is a another way to display a file&rsquo;s contents without using <code>cat</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#0086b3">echo</span> <span style="color:#d14">&#34;</span><span style="color:#000;font-weight:bold">$(</span>&lt;file.txt<span style="color:#000;font-weight:bold">)</span><span style="color:#d14">&#34;</span>
</span></span></code></pre></div><p>this method uses redirection and command substitution, and is mentioned in the bash man page:</p>
<blockquote>
<p>The command substitution $(cat file) can be replaced by the equivalent but faster $(&lt; file).</p>
</blockquote>
<p>It&rsquo;s faster, because you are not forking a cat, but does it matter? Probably not, and may not be clear to everyone what you are doing, but you can see a difference with a quick test on your shell:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ <span style="color:#0086b3">time</span> <span style="color:#000;font-weight:bold">for</span> n in <span style="color:#000;font-weight:bold">{</span>1..1000<span style="color:#000;font-weight:bold">}</span>; <span style="color:#000;font-weight:bold">do</span> <span style="color:#d14">\
</span></span></span><span style="display:flex;"><span><span style="color:#d14"></span>    <span style="color:#0086b3">echo</span> <span style="color:#000;font-weight:bold">$(</span>&lt;/etc/resolv.conf<span style="color:#000;font-weight:bold">)</span> &gt;/dev/null; <span style="color:#d14">\
</span></span></span><span style="display:flex;"><span><span style="color:#d14"></span>  <span style="color:#000;font-weight:bold">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>real	0m0.977s
</span></span><span style="display:flex;"><span>user	0m0.380s
</span></span><span style="display:flex;"><span>sys	0m0.604s
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ <span style="color:#0086b3">time</span> <span style="color:#000;font-weight:bold">for</span> n in <span style="color:#000;font-weight:bold">{</span>1..1000<span style="color:#000;font-weight:bold">}</span>; <span style="color:#000;font-weight:bold">do</span> <span style="color:#d14">\
</span></span></span><span style="display:flex;"><span><span style="color:#d14"></span>    cat /etc/resolv.conf &gt;/dev/null;
</span></span><span style="display:flex;"><span>  <span style="color:#000;font-weight:bold">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>real	0m1.980s
</span></span><span style="display:flex;"><span>user	0m0.626s
</span></span><span style="display:flex;"><span>sys	0m1.224s
</span></span></code></pre></div><p>This syntax <code>$(&lt;file.text)</code> may look a bit strange, what you are doing is command substitution, where the contents of <code>file.txt</code> are sent to STDIN which is then echo&rsquo;d as STDOUT. If you want to learn a bit more about redirection using <code>&gt;</code> and <code>&lt;</code> see my earlier post about <a href="/posts/shell-redirection/">shell redirection</a>.</p>
<h2 id="using-other-utilities">Using other utilities</h2>
<p>How about other options? Without using shell built-ins but instead using other standard utilities you can also cat without cat:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ul &lt; /file
</span></span></code></pre></div><p><code>ul</code> might inadvertently underline some words in your file but I think it might be the only way to cat a file with only two characters.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tac /file | tac
</span></span></code></pre></div><p>If you didn&rsquo;t already guess, <code>tac</code> is GNU core util that is the reverse of <code>cat</code> so if you want to be clever you can pipe the output of <code>tac</code> to <code>tac</code> which is just a <code>cat</code>.</p>
<p>Of course using tools like <code>sed</code>, <code>perl</code>, <code>python</code>, etc. will allow you to cat files as well, happy cat&rsquo;ing!</p>
<p><strong>Interested in other ways to cat without cat? Try the <a href="https://oops.cmdchallenge.com/#/oops_print_file_contents">oops challenge</a>!</strong></p>

</article>


        </main>
        <footer></footer>
    </body>
</html>
